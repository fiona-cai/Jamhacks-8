/********************************************************************************
 * MIT License

 * Â© Copyright 2023 Adobe. All rights reserved.

 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 ********************************************************************************/
import { AddOnManifestValidator } from "./AddOnManifestValidator.js";
import { AddOnManifestEntrypoint } from "./manifest-field/AddOnManifestEntrypoint.js";
import { AddOnManifestRequirement } from "./manifest-field/AddOnManifestRequirement.js";
export var ManifestVersion;
(function (ManifestVersion) {
    ManifestVersion[ManifestVersion["V1"] = 1] = "V1";
    ManifestVersion[ManifestVersion["V2"] = 2] = "V2";
})(ManifestVersion || (ManifestVersion = {}));
/**
 * Defines the getter methods for AddOn manifest fields
 */
export class AddOnManifest {
    _requirement;
    _entrypoints = [];
    _manifest;
    static createManifest(addOnInfo, addOnLogger) {
        // validate the manifest here and if rejected return
        const manifestValidator = new AddOnManifestValidator(addOnLogger);
        const schemaValidation = manifestValidator.validateManifestSchema(addOnInfo.manifest, addOnInfo.additionalInfo);
        let manifestValidationResult = { success: true };
        if (!schemaValidation.success) {
            manifestValidationResult = {
                success: false,
                errorDetails: schemaValidation.errorDetails,
                warningDetails: schemaValidation.warningDetails
            };
            return { manifestValidationResult };
        }
        return {
            manifestValidationResult,
            manifest: new AddOnManifest({ ...addOnInfo.manifest })
        };
    }
    /**
     * TODO: [WXP-1583] Updated the response type in [AddOnInfoApi.manifest] and remove the getter
     */
    get manifestProperties() {
        return this._manifest;
    }
    constructor(manifest) {
        const manifestVersion = manifest.manifestVersion;
        switch (manifestVersion) {
            case ManifestVersion.V1: {
                this._manifest = manifest;
                break;
            }
            default: {
                this._manifest = manifest;
            }
        }
    }
    get id() {
        switch (this._manifest.manifestVersion) {
            case ManifestVersion.V1: {
                const { id } = this._manifest;
                return id;
            }
            default: {
                return "";
            }
        }
    }
    get name() {
        switch (this._manifest.manifestVersion) {
            case ManifestVersion.V1: {
                const { name } = this._manifest;
                return name;
            }
            default: {
                return undefined;
            }
        }
    }
    get version() {
        return this._manifest.version;
    }
    get manifestVersion() {
        return this._manifest.manifestVersion || ManifestVersion.V1;
    }
    get requirements() {
        if (!this._requirement) {
            this._requirement = new AddOnManifestRequirement(this._manifest.manifestVersion, this._manifest.requirements);
        }
        return this._requirement;
    }
    get icon() {
        switch (this._manifest.manifestVersion) {
            case ManifestVersion.V1: {
                const { icon } = this._manifest;
                return icon;
            }
            default: {
                return undefined;
            }
        }
    }
    get entryPoints() {
        if (!this._entrypoints.length) {
            this._manifest.entryPoints.forEach(entrypoint => {
                this._entrypoints.push(new AddOnManifestEntrypoint(this._manifest.manifestVersion, entrypoint));
            });
        }
        return this._entrypoints;
    }
    get authorInfo() {
        switch (this._manifest.manifestVersion) {
            case ManifestVersion.V1: {
                const { authorInfo } = this._manifest;
                return authorInfo;
            }
            default: {
                return undefined;
            }
        }
    }
}
//# sourceMappingURL=AddOnManifest.js.map