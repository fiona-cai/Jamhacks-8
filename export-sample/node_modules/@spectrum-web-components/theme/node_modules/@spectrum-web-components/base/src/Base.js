var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __decorateClass = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;
  for (var i = decorators.length - 1, decorator; i >= 0; i--)
    if (decorator = decorators[i])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp(target, key, result);
  return result;
};
import { LitElement } from "lit";
import { property } from "lit/decorators.js";
const observedForElements = /* @__PURE__ */ new Set();
const updateRTL = () => {
  const dir = document.documentElement.dir === "rtl" ? document.documentElement.dir : "ltr";
  observedForElements.forEach((el) => {
    el.setAttribute("dir", dir);
  });
};
const rtlObserver = new MutationObserver(updateRTL);
rtlObserver.observe(document.documentElement, {
  attributes: true,
  attributeFilter: ["dir"]
});
const canManageContentDirection = (el) => typeof el.startManagingContentDirection !== "undefined" || el.tagName === "SP-THEME";
export function SpectrumMixin(constructor) {
  class SlotTextObservingElement extends constructor {
    constructor() {
      super(...arguments);
      this.dir = "ltr";
    }
    get isLTR() {
      return this.dir === "ltr";
    }
    hasVisibleFocusInTree() {
      const activeElement = this.getRootNode().activeElement;
      if (!activeElement) {
        return false;
      }
      try {
        return activeElement.matches(":focus-visible") || activeElement.matches(".focus-visible");
      } catch (error) {
        return activeElement.matches(".focus-visible");
      }
    }
    connectedCallback() {
      if (!this.hasAttribute("dir")) {
        let dirParent = this.assignedSlot || this.parentNode;
        while (dirParent !== document.documentElement && !canManageContentDirection(dirParent)) {
          dirParent = dirParent.assignedSlot || dirParent.parentNode || dirParent.host;
        }
        const oldDir = this.dir;
        this.dir = dirParent.dir === "rtl" ? dirParent.dir : this.dir || "ltr";
        if (oldDir === this.dir) {
          this.setAttribute("dir", this.dir);
        }
        if (dirParent === document.documentElement) {
          observedForElements.add(this);
        } else {
          const { localName } = dirParent;
          if (localName.search("-") > -1 && !customElements.get(localName)) {
            customElements.whenDefined(localName).then(() => {
              dirParent.startManagingContentDirection(this);
            });
          } else {
            dirParent.startManagingContentDirection(this);
          }
        }
        this._dirParent = dirParent;
      }
      super.connectedCallback();
    }
    disconnectedCallback() {
      super.disconnectedCallback();
      if (this._dirParent) {
        if (this._dirParent === document.documentElement) {
          observedForElements.delete(this);
        } else {
          this._dirParent.stopManagingContentDirection(this);
        }
        this.removeAttribute("dir");
      }
    }
  }
  __decorateClass([
    property({ reflect: true })
  ], SlotTextObservingElement.prototype, "dir", 2);
  return SlotTextObservingElement;
}
export class SpectrumElement extends SpectrumMixin(LitElement) {
}
if (false) {
  window.__swc = {
    ...window.__swc,
    issuedWarnings: /* @__PURE__ */ new Set(),
    warn: (element, message, url, { type = "api", level = "default", issues } = {}) => {
      var _a, _b, _c;
      const { localName = "base" } = element || {};
      const id = `${localName}:${type}:${level}`;
      if (!window.__swc.verbose && window.__swc.issuedWarnings.has(id))
        return;
      window.__swc.issuedWarnings.add(id);
      if ((_a = window.__swc.ignoreWarningLocalNames) == null ? void 0 : _a[localName])
        return;
      if ((_b = window.__swc.ignoreWarningTypes) == null ? void 0 : _b[type])
        return;
      if ((_c = window.__swc.ignoreWarningLevels) == null ? void 0 : _c[level])
        return;
      let listedIssues = "";
      if (issues && issues.length) {
        issues.unshift("");
        listedIssues = issues.join("\n    - ") + "\n";
      }
      const intro = level === "deprecation" ? "DEPRECATION NOTICE: " : "";
      const inspectElement = element ? "\nInspect this issue in the follow element:" : "";
      const displayURL = (element ? "\n\n" : "\n") + url + "\n";
      const messages = [];
      messages.push(intro + message + "\n" + listedIssues + inspectElement);
      if (element) {
        messages.push(element);
      }
      messages.push(displayURL, {
        data: {
          localName,
          type,
          level
        }
      });
      console.warn(...messages);
    }
  };
  window.__swc.warn(void 0, "Spectrum Web Components is in dev mode. Not recommended for production!", "https://opensource.adobe.com/spectrum-web-components/dev-mode/", { type: "default" });
}
//# sourceMappingURL=Base.js.map
