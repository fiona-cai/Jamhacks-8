"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __decorateClass = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;
  for (var i = decorators.length - 1, decorator; i >= 0; i--)
    if (decorator = decorators[i])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp(target, key, result);
  return result;
};
import {
  html,
  nothing,
  render,
  SizedMixin
} from "@spectrum-web-components/base";
import { classMap } from "@spectrum-web-components/base/src/directives.js";
import {
  property,
  query
} from "@spectrum-web-components/base/src/decorators.js";
import pickerStyles from "./picker.css.js";
import chevronStyles from "@spectrum-web-components/icon/src/spectrum-icon-chevron.css.js";
import { Focusable } from "@spectrum-web-components/shared/src/focusable.js";
import { reparentChildren } from "@spectrum-web-components/shared/src/reparent-children.js";
import "@spectrum-web-components/icons-ui/icons/sp-icon-chevron100.js";
import "@spectrum-web-components/icons-workflow/icons/sp-icon-alert.js";
import "@spectrum-web-components/menu/sp-menu.js";
import "@spectrum-web-components/tray/sp-tray.js";
import "@spectrum-web-components/popover/sp-popover.js";
import {
  openOverlay
} from "@spectrum-web-components/overlay";
import {
  IS_MOBILE,
  MatchMediaController
} from "@spectrum-web-components/reactive-controllers/src/MatchMedia.js";
const chevronClass = {
  s: "spectrum-UIIcon-ChevronDown75",
  m: "spectrum-UIIcon-ChevronDown100",
  l: "spectrum-UIIcon-ChevronDown200",
  xl: "spectrum-UIIcon-ChevronDown300"
};
export class PickerBase extends SizedMixin(Focusable) {
  constructor() {
    super();
    this.isMobile = new MatchMediaController(this, IS_MOBILE);
    this.disabled = false;
    this.focused = false;
    this.invalid = false;
    this.open = false;
    this.readonly = false;
    this.selects = "single";
    this.menuItems = [];
    this.placement = "bottom-start";
    this.quiet = false;
    this.value = "";
    this.listRole = "listbox";
    this.itemRole = "option";
    this.onKeydown = (event) => {
      this.focused = true;
      if (event.code !== "ArrowDown" && event.code !== "ArrowUp") {
        return;
      }
      event.preventDefault();
      this.toggle(true);
    };
    this.overlayOpenCallback = async () => {
      this.updateMenuItems();
      await this.itemsUpdated;
      await this.optionsMenu.updateComplete;
      requestAnimationFrame(() => this.menuStateResolver());
    };
    this.overlayCloseCallback = async () => {
      if (this.restoreChildren) {
        this.restoreChildren();
        this.restoreChildren = void 0;
      }
      this.close();
      requestAnimationFrame(() => this.menuStateResolver());
    };
    this._willUpdateItems = false;
    this.itemsUpdated = Promise.resolve();
    this.menuStatePromise = Promise.resolve();
    this.selectionPromise = Promise.resolve();
    this.onKeydown = this.onKeydown.bind(this);
  }
  get target() {
    return this.button;
  }
  get focusElement() {
    if (this.open) {
      return this.optionsMenu;
    }
    return this.button;
  }
  forceFocusVisible() {
    this.focused = true;
  }
  onButtonBlur() {
    this.focused = false;
    this.target.removeEventListener(
      "keydown",
      this.onKeydown
    );
  }
  onButtonClick() {
    this.toggle();
  }
  focus(options) {
    super.focus(options);
    if (!this.disabled && this.focusElement) {
      this.focused = this.hasVisibleFocusInTree();
    }
  }
  onHelperFocus() {
    this.focused = true;
    this.button.focus();
  }
  onButtonFocus() {
    this.target.addEventListener(
      "keydown",
      this.onKeydown
    );
  }
  handleChange(event) {
    const target = event.target;
    const [selected] = target.selectedItems;
    if (event.cancelable) {
      event.stopPropagation();
      this.setValueFromItem(selected, event);
    } else {
      this.open = false;
    }
  }
  async setValueFromItem(item, menuChangeEvent) {
    const oldSelectedItem = this.selectedItem;
    const oldValue = this.value;
    this.selectedItem = item;
    this.value = item.value;
    this.open = false;
    await this.updateComplete;
    const applyDefault = this.dispatchEvent(
      new Event("change", {
        bubbles: true,
        cancelable: true,
        composed: true
      })
    );
    if (!applyDefault) {
      if (menuChangeEvent) {
        menuChangeEvent.preventDefault();
      }
      this.setMenuItemSelected(this.selectedItem, false);
      if (oldSelectedItem) {
        this.setMenuItemSelected(oldSelectedItem, true);
      }
      this.selectedItem = oldSelectedItem;
      this.value = oldValue;
      this.open = true;
      return;
    }
    if (oldSelectedItem) {
      this.setMenuItemSelected(oldSelectedItem, false);
    }
    this.setMenuItemSelected(item, !!this.selects);
  }
  setMenuItemSelected(item, value) {
    if (this.selects == null)
      return;
    item.selected = value;
  }
  toggle(target) {
    if (this.readonly) {
      return;
    }
    this.open = typeof target !== "undefined" ? target : !this.open;
  }
  close() {
    if (this.readonly) {
      return;
    }
    this.open = false;
  }
  async generatePopover() {
    if (!this.popoverFragment) {
      this.popoverFragment = document.createDocumentFragment();
    }
    render(this.renderPopover, this.popoverFragment, { host: this });
    this.popoverEl = this.popoverFragment.children[0];
    this.optionsMenu = this.popoverEl.children[1];
  }
  async openMenu() {
    let reparentableChildren = [];
    const deprecatedMenu = this.querySelector(":scope > sp-menu");
    await this.generatePopover();
    if (deprecatedMenu) {
      reparentableChildren = Array.from(deprecatedMenu.children);
    } else {
      reparentableChildren = Array.from(this.children).filter(
        (element) => {
          return !element.hasAttribute("slot");
        }
      );
    }
    if (reparentableChildren.length === 0) {
      this.menuStateResolver();
      return;
    }
    this.restoreChildren = reparentChildren(reparentableChildren, this.optionsMenu, {
      position: "beforeend",
      prepareCallback: (el) => {
        if (this.value === el.value) {
          this.setMenuItemSelected(el, true);
        }
        return (el2) => {
          if (typeof el2.focused !== "undefined") {
            el2.focused = false;
          }
        };
      }
    });
    this.sizePopover(this.popoverEl);
    if (true) {
      window.__swc.ignoreWarningLevels.deprecation = true;
    }
    this.closeOverlay = Picker.openOverlay(this, "modal", this.popoverEl, {
      placement: this.isMobile.matches ? "none" : this.placement,
      receivesFocus: "auto"
    });
    if (true) {
      window.__swc.ignoreWarningLevels.deprecation = false;
    }
  }
  sizePopover(popover) {
    if (this.isMobile.matches) {
      popover.style.setProperty("--swc-menu-width", `100%`);
      return;
    }
    if (this.quiet)
      return;
    popover.style.setProperty("min-width", `${this.offsetWidth}px`);
  }
  async closeMenu() {
    if (this.closeOverlay) {
      const closeOverlay = this.closeOverlay;
      delete this.closeOverlay;
      (await closeOverlay)();
    }
  }
  get selectedItemContent() {
    if (this.selectedItem) {
      return this.selectedItem.itemChildren;
    }
    return { icon: [], content: [] };
  }
  renderLabelContent(content) {
    if (this.value && this.selectedItem) {
      return content;
    }
    return html`
            <slot name="label">${this.label}</slot>
        `;
  }
  get buttonContent() {
    const labelClasses = {
      "visually-hidden": this.icons === "only" && !!this.value,
      placeholder: !this.value
    };
    return [
      html`
                <span id="icon" ?hidden=${this.icons === "none"}>
                    ${this.selectedItemContent.icon}
                </span>
                <span id="label" class=${classMap(labelClasses)}>
                    ${this.renderLabelContent(this.selectedItemContent.content)}
                </span>
                ${this.invalid ? html`
                          <sp-icon-alert
                              class="validation-icon"
                          ></sp-icon-alert>
                      ` : nothing}
                <sp-icon-chevron100
                    class="picker ${chevronClass[this.size]}"
                ></sp-icon-chevron100>
            `
    ];
  }
  // a helper to throw focus to the button is needed because Safari
  // won't include buttons in the tab order even with tabindex="0"
  render() {
    return html`
            <span
                id="focus-helper"
                tabindex="${this.focused ? "-1" : "0"}"
                @focus=${this.onHelperFocus}
            ></span>
            <button
                aria-haspopup="true"
                aria-expanded=${this.open ? "true" : "false"}
                aria-labelledby="button icon label"
                id="button"
                class="button"
                @blur=${this.onButtonBlur}
                @click=${this.onButtonClick}
                @focus=${this.onButtonFocus}
                ?disabled=${this.disabled}
                tabindex="-1"
            >
                ${this.buttonContent}
            </button>
        `;
  }
  update(changes) {
    if (this.selects) {
      this.selects = "single";
    }
    if (changes.has("disabled") && this.disabled) {
      this.open = false;
    }
    if (changes.has("open") && (this.open || typeof changes.get("open") !== "undefined")) {
      this.menuStatePromise = new Promise(
        (res) => this.menuStateResolver = res
      );
      if (this.open) {
        this.openMenu();
      } else {
        this.closeMenu();
      }
    }
    if (changes.has("value") && !changes.has("selectedItem")) {
      this.updateMenuItems();
    }
    if (true) {
      if (!this.hasUpdated && this.querySelector("sp-menu")) {
        const { localName } = this;
        window.__swc.warn(
          this,
          `You no longer need to provide an <sp-menu> child to ${localName}. Any styling or attributes on the <sp-menu> will be ignored.`,
          "https://opensource.adobe.com/spectrum-web-components/components/picker/#sizes",
          { level: "deprecation" }
        );
      }
    }
    super.update(changes);
  }
  get dismissHelper() {
    return html`
            <div class="visually-hidden">
                <button
                    tabindex="-1"
                    arial-label="Dismiss"
                    @click=${this.close}
                ></button>
            </div>
        `;
  }
  get renderPopover() {
    const content = html`
            ${this.dismissHelper}
            <sp-menu
                id="menu"
                role="${this.listRole}"
                @change=${this.handleChange}
                .selects=${this.selects}
            ></sp-menu>
            ${this.dismissHelper}
        `;
    if (this.isMobile.matches) {
      return html`
                <sp-tray
                    id="popover"
                    role="dialog"
                    @sp-menu-item-added-or-updated=${this.updateMenuItems}
                    .overlayOpenCallback=${this.overlayOpenCallback}
                    .overlayCloseCallback=${this.overlayCloseCallback}
                >
                    ${content}
                </sp-tray>
            `;
    }
    return html`
            <sp-popover
                id="popover"
                role="dialog"
                @sp-menu-item-added-or-updated=${this.updateMenuItems}
                .overlayOpenCallback=${this.overlayOpenCallback}
                .overlayCloseCallback=${this.overlayCloseCallback}
            >
                ${content}
            </sp-popover>
        `;
  }
  /**
   * Acquire the available MenuItems in the Picker by
   * direct element query or by assuming the list managed
   * by the Menu within the open options overlay.
   */
  updateMenuItems(event) {
    if (this.open && (event == null ? void 0 : event.type) === "sp-menu-item-removed")
      return;
    if (this._willUpdateItems)
      return;
    this._willUpdateItems = true;
    if ((event == null ? void 0 : event.item) === this.selectedItem) {
      this.requestUpdate();
    }
    let resolve = () => {
      return;
    };
    this.itemsUpdated = new Promise((res) => resolve = res);
    window.requestAnimationFrame(async () => {
      if (this.open) {
        await this.optionsMenu.updateComplete;
        this.menuItems = this.optionsMenu.childItems;
      } else {
        this.menuItems = [
          ...this.querySelectorAll(
            'sp-menu-item:not([slot="submenu"] *)'
          )
        ];
      }
      this.manageSelection();
      resolve();
      this._willUpdateItems = false;
    });
  }
  async manageSelection() {
    if (this.selects == null)
      return;
    await this.menuStatePromise;
    this.selectionPromise = new Promise(
      (res) => this.selectionResolver = res
    );
    let selectedItem;
    this.menuItems.forEach((item) => {
      if (this.value === item.value && !item.disabled) {
        selectedItem = item;
      } else {
        item.selected = false;
      }
    });
    if (selectedItem) {
      selectedItem.selected = !!this.selects;
      this.selectedItem = selectedItem;
    } else {
      this.value = "";
      this.selectedItem = void 0;
    }
    if (this.open) {
      await this.optionsMenu.updateComplete;
      this.optionsMenu.updateSelectedItemIndex();
    }
    this.selectionResolver();
  }
  async getUpdateComplete() {
    const complete = await super.getUpdateComplete();
    await this.menuStatePromise;
    await this.itemsUpdated;
    await this.selectionPromise;
    return complete;
  }
  connectedCallback() {
    this.updateMenuItems();
    this.addEventListener(
      "sp-menu-item-added-or-updated",
      this.updateMenuItems
    );
    this.addEventListener("sp-menu-item-removed", this.updateMenuItems);
    super.connectedCallback();
  }
  disconnectedCallback() {
    this.close();
    super.disconnectedCallback();
  }
}
/**
 * @private
 */
PickerBase.openOverlay = async (target, interaction, content, options) => {
  return await openOverlay(target, interaction, content, options);
};
__decorateClass([
  query("#button")
], PickerBase.prototype, "button", 2);
__decorateClass([
  property({ type: Boolean, reflect: true })
], PickerBase.prototype, "disabled", 2);
__decorateClass([
  property({ type: Boolean, reflect: true })
], PickerBase.prototype, "focused", 2);
__decorateClass([
  property({ type: String, reflect: true })
], PickerBase.prototype, "icons", 2);
__decorateClass([
  property({ type: Boolean, reflect: true })
], PickerBase.prototype, "invalid", 2);
__decorateClass([
  property()
], PickerBase.prototype, "label", 2);
__decorateClass([
  property({ type: Boolean, reflect: true })
], PickerBase.prototype, "open", 2);
__decorateClass([
  property({ type: Boolean, reflect: true })
], PickerBase.prototype, "readonly", 2);
__decorateClass([
  property()
], PickerBase.prototype, "placement", 2);
__decorateClass([
  property({ type: Boolean, reflect: true })
], PickerBase.prototype, "quiet", 2);
__decorateClass([
  property({ type: String })
], PickerBase.prototype, "value", 2);
__decorateClass([
  property({ attribute: false })
], PickerBase.prototype, "selectedItem", 2);
export class Picker extends PickerBase {
  constructor() {
    super(...arguments);
    this.onKeydown = (event) => {
      const { code } = event;
      this.focused = true;
      if (!code.startsWith("Arrow") || this.readonly) {
        return;
      }
      event.preventDefault();
      if (code === "ArrowUp" || code === "ArrowDown") {
        this.toggle(true);
        return;
      }
      const selectedIndex = this.selectedItem ? this.menuItems.indexOf(this.selectedItem) : -1;
      const nextOffset = !this.value || code === "ArrowRight" ? 1 : -1;
      let nextIndex = selectedIndex + nextOffset;
      while (this.menuItems[nextIndex] && this.menuItems[nextIndex].disabled) {
        nextIndex += nextOffset;
      }
      if (!this.menuItems[nextIndex] || this.menuItems[nextIndex].disabled) {
        return;
      }
      if (!this.value || nextIndex !== selectedIndex) {
        this.setValueFromItem(this.menuItems[nextIndex]);
      }
    };
  }
  static get styles() {
    return [pickerStyles, chevronStyles];
  }
}
//# sourceMappingURL=Picker.dev.js.map
