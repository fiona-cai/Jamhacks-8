"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.removeDomain = exports.configuredDomains = exports.hasCertificateFor = exports.certificateFor = exports.uninstall = void 0;
const tslib_1 = require("tslib");
const command_exists_1 = require("command-exists");
const debug_1 = tslib_1.__importDefault(require("debug"));
const fs_1 = require("fs");
const is_valid_domain_1 = tslib_1.__importDefault(require("is-valid-domain"));
const rimraf_1 = tslib_1.__importDefault(require("rimraf"));
const certificate_authority_1 = tslib_1.__importStar(require("./certificate-authority"));
Object.defineProperty(exports, "uninstall", { enumerable: true, get: function () { return certificate_authority_1.uninstall; } });
const certificates_1 = require("./certificates");
const constants_1 = require("./constants");
const platforms_1 = tslib_1.__importDefault(require("./platforms"));
const user_interface_1 = tslib_1.__importDefault(require("./user-interface"));
const debug = debug_1.default("devcert");
/**
 * Request an SSL certificate for the given app name signed by the devcert root
 * certificate authority. If devcert has previously generated a certificate for
 * that app name on this machine, it will reuse that certificate.
 *
 * If this is the first time devcert is being run on this machine, it will
 * generate and attempt to install a root certificate authority.
 *
 * Returns a promise that resolves with { key, cert }, where `key` and `cert`
 * are Buffers with the contents of the certificate private key and certificate
 * file, respectively
 *
 * If `options.getCaBuffer` is true, return value will include the ca certificate data
 * as { ca: Buffer }
 *
 * If `options.getCaPath` is true, return value will include the ca certificate path
 * as { caPath: string }
 */
function certificateFor(requestedDomains, options = {}) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const domains = Array.isArray(requestedDomains) ? requestedDomains : [requestedDomains];
        domains.forEach((domain) => {
            if (domain !== "localhost" &&
                !is_valid_domain_1.default(domain, { subdomain: true, wildcard: false, allowUnicode: true, topLevel: false })) {
                throw new Error(`"${domain}" is not a valid domain name.`);
            }
        });
        const domainPath = constants_1.getStableDomainPath(domains);
        debug(`Certificate requested for ${domains}. Skipping certutil install: ${Boolean(options.skipCertutilInstall)}. Skipping hosts file: ${Boolean(options.skipHostsFile)}`);
        if (options.ui) {
            Object.assign(user_interface_1.default, options.ui);
        }
        if (!constants_1.isMac && !constants_1.isLinux && !constants_1.isWindows) {
            throw new Error(`Platform not supported: "${process.platform}"`);
        }
        if (!command_exists_1.sync("openssl")) {
            throw new Error("OpenSSL not found: OpenSSL is required to generate SSL certificates - make sure it is installed and available in your PATH");
        }
        let domainKeyPath = constants_1.pathForDomain(domainPath, `private-key.key`);
        let domainCertPath = constants_1.pathForDomain(domainPath, `certificate.crt`);
        if (!fs_1.existsSync(constants_1.rootCAKeyPath)) {
            debug("Root CA is not installed yet, so it must be our first run. Installing root CA ...");
            yield certificate_authority_1.default(options);
        }
        else if (options.getCaBuffer || options.getCaPath) {
            debug("Root CA is not readable, but it probably is because an earlier version of devcert locked it. Trying to fix...");
            yield certificate_authority_1.ensureCACertReadable(options);
        }
        if (!fs_1.existsSync(constants_1.pathForDomain(domainPath, `certificate.crt`))) {
            debug(`Can't find certificate file for ${domains}, so it must be the first request for ${domains}. Generating and caching ...`);
            yield certificates_1.generateDomainCertificate(domains);
        }
        if (!options.skipHostsFile) {
            domains.forEach((domain) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                yield platforms_1.default.addDomainToHostFileIfMissing(domain);
            }));
        }
        debug(`Returning domain certificate`);
        const ret = {
            key: fs_1.readFileSync(domainKeyPath),
            cert: fs_1.readFileSync(domainCertPath),
        };
        if (options.getCaBuffer)
            ret.ca = fs_1.readFileSync(constants_1.rootCACertPath);
        if (options.getCaPath)
            ret.caPath = constants_1.rootCACertPath;
        return ret;
    });
}
exports.certificateFor = certificateFor;
function hasCertificateFor(requestedDomains) {
    const domains = Array.isArray(requestedDomains) ? requestedDomains : [requestedDomains];
    const domainPath = constants_1.getStableDomainPath(domains);
    return fs_1.existsSync(constants_1.pathForDomain(domainPath, `certificate.crt`));
}
exports.hasCertificateFor = hasCertificateFor;
function configuredDomains() {
    return fs_1.readdirSync(constants_1.domainsDir);
}
exports.configuredDomains = configuredDomains;
function removeDomain(requestedDomains) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const domains = Array.isArray(requestedDomains) ? requestedDomains : [requestedDomains];
        yield certificates_1.revokeDomainCertificate(domains);
        const domainPath = constants_1.getStableDomainPath(domains);
        return rimraf_1.default.sync(constants_1.pathForDomain(domainPath));
    });
}
exports.removeDomain = removeDomain;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiLi8iLCJzb3VyY2VzIjpbImluZGV4LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7QUFBQSxtREFBdUQ7QUFDdkQsMERBQWdDO0FBQ2hDLDJCQUE0RjtBQUM1Riw4RUFBNEM7QUFDNUMsNERBQTRCO0FBQzVCLHlGQUF1RztBQWM5RiwwRkFkbUQsaUNBQVMsT0FjbkQ7QUFibEIsaURBQW9GO0FBQ3BGLDJDQVNxQjtBQUNyQixvRUFBMEM7QUFDMUMsOEVBQXFEO0FBR3JELE1BQU0sS0FBSyxHQUFHLGVBQVcsQ0FBQyxTQUFTLENBQUMsQ0FBQztBQTZCckM7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBaUJHO0FBQ0gsU0FBc0IsY0FBYyxDQUNoQyxnQkFBbUMsRUFDbkMsVUFBYSxFQUFPOztRQUVwQixNQUFNLE9BQU8sR0FBRyxLQUFLLENBQUMsT0FBTyxDQUFDLGdCQUFnQixDQUFDLENBQUMsQ0FBQyxDQUFDLGdCQUFnQixDQUFDLENBQUMsQ0FBQyxDQUFDLGdCQUFnQixDQUFDLENBQUM7UUFDeEYsT0FBTyxDQUFDLE9BQU8sQ0FBQyxDQUFDLE1BQU0sRUFBRSxFQUFFO1lBQ3ZCLElBQ0ksTUFBTSxLQUFLLFdBQVc7Z0JBQ3RCLENBQUMseUJBQWEsQ0FBQyxNQUFNLEVBQUUsRUFBRSxTQUFTLEVBQUUsSUFBSSxFQUFFLFFBQVEsRUFBRSxLQUFLLEVBQUUsWUFBWSxFQUFFLElBQUksRUFBRSxRQUFRLEVBQUUsS0FBSyxFQUFFLENBQUMsRUFDbkc7Z0JBQ0UsTUFBTSxJQUFJLEtBQUssQ0FBQyxJQUFJLE1BQU0sK0JBQStCLENBQUMsQ0FBQzthQUM5RDtRQUNMLENBQUMsQ0FBQyxDQUFDO1FBRUgsTUFBTSxVQUFVLEdBQUcsK0JBQW1CLENBQUMsT0FBTyxDQUFDLENBQUM7UUFDaEQsS0FBSyxDQUNELDZCQUE2QixPQUFPLGdDQUFnQyxPQUFPLENBQ3ZFLE9BQU8sQ0FBQyxtQkFBbUIsQ0FDOUIsMEJBQTBCLE9BQU8sQ0FBQyxP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LENBQUMsQ0FBQyxDQUFDLENBQUMsZ0JBQWdCLENBQUMsQ0FBQyxDQUFDLENBQUMsZ0JBQWdCLENBQUMsQ0FBQztRQUN4RixNQUFNLHNDQUF1QixDQUFDLE9BQU8sQ0FBQyxDQUFDO1FBRXZDLE1BQU0sVUFBVSxHQUFHLCtCQUFtQixDQUFDLE9BQU8sQ0FBQyxDQUFDO1FBQ2hELE9BQU8sZ0JBQU0sQ0FBQyxJQUFJLENBQUMseUJBQWEsQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDO0lBQ2xELENBQUM7Q0FBQTtBQU5ELG9DQU1DIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgc3luYyBhcyBjb21tYW5kRXhpc3RzIH0gZnJvbSBcImNvbW1hbmQtZXhpc3RzXCI7XG5pbXBvcnQgY3JlYXRlRGVidWcgZnJvbSBcImRlYnVnXCI7XG5pbXBvcnQgeyBleGlzdHNTeW5jIGFzIGV4aXN0cywgcmVhZEZpbGVTeW5jIGFzIHJlYWRGaWxlLCByZWFkZGlyU3luYyBhcyByZWFkZGlyIH0gZnJvbSBcImZzXCI7XG5pbXBvcnQgaXNWYWxpZERvbWFpbiBmcm9tIFwiaXMtdmFsaWQtZG9tYWluXCI7XG5pbXBvcnQgcmltcmFmIGZyb20gXCJyaW1yYWZcIjtcbmltcG9ydCBpbnN0YWxsQ2VydGlmaWNhdGVBdXRob3JpdHksIHsgZW5zdXJlQ0FDZXJ0UmVhZGFibGUsIHVuaW5zdGFsbCB9IGZyb20gXCIuL2NlcnRpZmljYXRlLWF1dGhvcml0eVwiO1xuaW1wb3J0IHsgZ2VuZXJhdGVEb21haW5DZXJ0aWZpY2F0ZSwgcmV2b2tlRG9tYWluQ2VydGlmaWNhdGUgfSBmcm9tIFwiLi9jZXJ0aWZpY2F0ZXNcIjtcbmltcG9ydCB7XG4gICAgZG9tYWluc0RpcixcbiAgICBnZXRTdGFibGVEb21haW5QYXRoLFxuICAgIGlzTGludXgsXG4gICAgaXNNYWMsXG4gICAgaXNXaW5kb3dzLFxuICAgIHBhdGhGb3JEb21haW4sXG4gICAgcm9vdENBQ2VydFBhdGgsXG4gICAgcm9vdENBS2V5UGF0aCxcbn0gZnJvbSBcIi4vY29uc3RhbnRzXCI7XG5pbXBvcnQgY3VycmVudFBsYXRmb3JtIGZyb20gXCIuL3BsYXRmb3Jtc1wiO1xuaW1wb3J0IFVJLCB7IFVzZXJJbnRlcmZhY2UgfSBmcm9tIFwiLi91c2VyLWludGVyZmFjZVwiO1xuZXhwb3J0IHsgdW5pbnN0YWxsIH07XG5cbmNvbnN0IGRlYnVnID0gY3JlYXRlRGVidWcoXCJkZXZjZXJ0XCIpO1xuXG5leHBvcnQgaW50ZXJmYWNlIE9wdGlvbnMgLyogZXh0ZW5kcyBQYXJ0aWFsPElDYUJ1ZmZlck9wdHMgJiBJQ2FQYXRoT3B0cz4gICovIHtcbiAgICAvKiogUmV0dXJuIHRoZSBDQSBjZXJ0aWZpY2F0ZSBkYXRhPyAqL1xuICAgIGdldENhQnVmZmVyPzogYm9vbGVhbjtcbiAgICAvKiogUmV0dXJuIHRoZSBwYXRoIHRvIHRoZSBDQSBjZXJ0aWZpY2F0ZT8gKi9cbiAgICBnZXRDYVBhdGg/OiBib29sZWFuO1xuICAgIC8qKiBJZiBgY2VydHV0aWxgIGlzIG5vdCBpbnN0YWxsZWQgYWxyZWFkeSAoZm9yIHVwZGF0aW5nIG5zcyBkYXRhYmFzZXM7IGUuZy4gZmlyZWZveCksIGRvIG5vdCBhdHRlbXB0IHRvIGluc3RhbGwgaXQgKi9cbiAgICBza2lwQ2VydHV0aWxJbnN0YWxsPzogYm9vbGVhbjtcbiAgICAvKiogRG8gbm90IHVwZGF0ZSB5b3VyIHN5c3RlbXMgaG9zdCBmaWxlIHdpdGggdGhlIGRvbWFpbiBuYW1lIG9mIHRoZSBjZXJ0aWZpY2F0ZSAqL1xuICAgIHNraXBIb3N0c0ZpbGU/OiBib29sZWFuO1xuICAgIC8qKiBVc2VyIGludGVyZmFjZSBob29rcyAqL1xuICAgIHVpPzogVXNlckludGVyZmFjZTtcbn1cblxuaW50ZXJmYWNlIElDYUJ1ZmZlciB7XG4gICAgY2E6IEJ1ZmZlcjtcbn1cbmludGVyZmFjZSBJQ2FQYXRoIHtcbiAgICBjYVBhdGg6IHN0cmluZztcbn1cbmludGVyZmFjZSBJRG9tYWluRGF0YSB7XG4gICAga2V5OiBCdWZmZXI7XG4gICAgY2VydDogQnVmZmVyO1xufVxudHlwZSBJUmV0dXJuQ2E8TyBleHRlbmRzIE9wdGlvbnM+ID0gT1tcImdldENhQnVmZmVyXCJdIGV4dGVuZHMgdHJ1ZSA/IElDYUJ1ZmZlciA6IGZhbHNlO1xudHlwZSBJUmV0dXJuQ2FQYXRoPE8gZXh0ZW5kcyBPcHRpb25zPiA9IE9bXCJnZXRDYVBhdGhcIl0gZXh0ZW5kcyB0cnVlID8gSUNhUGF0aCA6IGZhbHNlO1xudHlwZSBJUmV0dXJuRGF0YTxPIGV4dGVuZHMgT3B0aW9ucyA9IHt9PiA9IElEb21haW5EYXRhICYgSVJldHVybkNhPE8+ICYgSVJldHVybkNhUGF0aDxPPjtcblxuLyoqXG4gKiBSZXF1ZXN0IGFuIFNTTCBjZXJ0aWZpY2F0ZSBmb3IgdGhlIGdpdmVuIGFwcCBuYW1lIHNpZ25lZCBieSB0aGUgZGV2Y2VydCByb290XG4gKiBjZXJ0aWZpY2F0ZSBhdXRob3JpdHkuIElmIGRldmNlcnQgaGFzIHByZXZpb3VzbHkgZ2VuZXJhdGVkIGEgY2VydGlmaWNhdGUgZm9yXG4gKiB0aGF0IGFwcCBuYW1lIG9uIHRoaXMgbWFjaGluZSwgaXQgd2lsbCByZXVzZSB0aGF0IGNlcnRpZmljYXRlLlxuICpcbiAqIElmIHRoaXMgaXMgdGhlIGZpcnN0IHRpbWUgZGV2Y2VydCBpcyBiZWluZyBydW4gb24gdGhpcyBtYWNoaW5lLCBpdCB3aWxsXG4gKiBnZW5lcmF0ZSBhbmQgYXR0ZW1wdCB0byBpbnN0YWxsIGEgcm9vdCBjZXJ0aWZpY2F0ZSBhdXRob3JpdHkuXG4gKlxuICogUmV0dXJucyBhIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIHsga2V5LCBjZXJ0IH0sIHdoZXJlIGBrZXlgIGFuZCBgY2VydGBcbiAqIGFyZSBCdWZmZXJzIHdpdGggdGhlIGNvbnRlbnRzIG9mIHRoZSBjZXJ0aWZpY2F0ZSBwcml2YXRlIGtleSBhbmQgY2VydGlmaWNhdGVcbiAqIGZpbGUsIHJlc3BlY3RpdmVseVxuICpcbiAqIElmIGBvcHRpb25zLmdldENhQnVmZmVyYCBpcyB0cnVlLCByZXR1cm4gdmFsdWUgd2lsbCBpbmNsdWRlIHRoZSBjYSBjZXJ0aWZpY2F0ZSBkYXRhXG4gKiBhcyB7IGNhOiBCdWZmZXIgfVxuICpcbiAqIElmIGBvcHRpb25zLmdldENhUGF0aGAgaXMgdHJ1ZSwgcmV0dXJuIHZhbHVlIHdpbGwgaW5jbHVkZSB0aGUgY2EgY2VydGlmaWNhdGUgcGF0aFxuICogYXMgeyBjYVBhdGg6IHN0cmluZyB9XG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjZXJ0aWZpY2F0ZUZvcjxPIGV4dGVuZHMgT3B0aW9ucz4oXG4gICAgcmVxdWVzdGVkRG9tYWluczogc3RyaW5nIHwgc3RyaW5nW10sXG4gICAgb3B0aW9uczogTyA9IHt9IGFzIE9cbik6IFByb21pc2U8SVJldHVybkRhdGE8Tz4+IHtcbiAgICBjb25zdCBkb21haW5zID0gQXJyYXkuaXNBcnJheShyZXF1ZXN0ZWREb21haW5zKSA/IHJlcXVlc3RlZERvbWFpbnMgOiBbcmVxdWVzdGVkRG9tYWluc107XG4gICAgZG9tYWlucy5mb3JFYWNoKChkb21haW4pID0+IHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgZG9tYWluICE9PSBcImxvY2FsaG9zdFwiICYmXG4gICAgICAgICAgICAhaXNWYWxpZERvbWFpbihkb21haW4sIHsgc3ViZG9tYWluOiB0cnVlLCB3aWxkY2FyZDogZmFsc2UsIGFsbG93VW5pY29kZTogdHJ1ZSwgdG9wTGV2ZWw6IGZhbHNlIH0pXG4gICAgICAgICkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBcIiR7ZG9tYWlufVwiIGlzIG5vdCBhIHZhbGlkIGRvbWFpbiBuYW1lLmApO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBjb25zdCBkb21haW5QYXRoID0gZ2V0U3RhYmxlRG9tYWluUGF0aChkb21haW5zKTtcbiAgICBkZWJ1ZyhcbiAgICAgICAgYENlcnRpZmljYXRlIHJlcXVlc3RlZCBmb3IgJHtkb21haW5zfS4gU2tpcHBpbmcgY2VydHV0aWwgaW5zdGFsbDogJHtCb29sZWFuKFxuICAgICAgICAgICAgb3B0aW9ucy5za2lwQ2VydHV0aWxJbnN0YWxsXG4gICAgICAgICl9LiBTa2lwcGluZyBob3N0cyBmaWxlOiAke0Jvb2xlYW4ob3B0aW9ucy5za2lwSG9zdHNGaWxlKX1gXG4gICAgKTtcblxuICAgIGlmIChvcHRpb25zLnVpKSB7XG4gICAgICAgIE9iamVjdC5hc3NpZ24oVUksIG9wdGlvbnMudWkpO1xuICAgIH1cblxuICAgIGlmICghaXNNYWMgJiYgIWlzTGludXggJiYgIWlzV2luZG93cykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFBsYXRmb3JtIG5vdCBzdXBwb3J0ZWQ6IFwiJHtwcm9jZXNzLnBsYXRmb3JtfVwiYCk7XG4gICAgfVxuXG4gICAgaWYgKCFjb21tYW5kRXhpc3RzKFwib3BlbnNzbFwiKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBcIk9wZW5TU0wgbm90IGZvdW5kOiBPcGVuU1NMIGlzIHJlcXVpcmVkIHRvIGdlbmVyYXRlIFNTTCBjZXJ0aWZpY2F0ZXMgLSBtYWtlIHN1cmUgaXQgaXMgaW5zdGFsbGVkIGFuZCBhdmFpbGFibGUgaW4geW91ciBQQVRIXCJcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBsZXQgZG9tYWluS2V5UGF0aCA9IHBhdGhGb3JEb21haW4oZG9tYWluUGF0aCwgYHByaXZhdGUta2V5LmtleWApO1xuICAgIGxldCBkb21haW5DZXJ0UGF0aCA9IHBhdGhGb3JEb21haW4oZG9tYWluUGF0aCwgYGNlcnRpZmljYXRlLmNydGApO1xuXG4gICAgaWYgKCFleGlzdHMocm9vdENBS2V5UGF0aCkpIHtcbiAgICAgICAgZGVidWcoXCJSb290IENBIGlzIG5vdCBpbnN0YWxsZWQgeWV0LCBzbyBpdCBtdXN0IGJlIG91ciBmaXJzdCBydW4uIEluc3RhbGxpbmcgcm9vdCBDQSAuLi5cIik7XG4gICAgICAgIGF3YWl0IGluc3RhbGxDZXJ0aWZpY2F0ZUF1dGhvcml0eShvcHRpb25zKTtcbiAgICB9IGVsc2UgaWYgKG9wdGlvbnMuZ2V0Q2FCdWZmZXIgfHwgb3B0aW9ucy5nZXRDYVBhdGgpIHtcbiAgICAgICAgZGVidWcoXG4gICAgICAgICAgICBcIlJvb3QgQ0EgaXMgbm90IHJlYWRhYmxlLCBidXQgaXQgcHJvYmFibHkgaXMgYmVjYXVzZSBhbiBlYXJsaWVyIHZlcnNpb24gb2YgZGV2Y2VydCBsb2NrZWQgaXQuIFRyeWluZyB0byBmaXguLi5cIlxuICAgICAgICApO1xuICAgICAgICBhd2FpdCBlbnN1cmVDQUNlcnRSZWFkYWJsZShvcHRpb25zKTtcbiAgICB9XG5cbiAgICBpZiAoIWV4aXN0cyhwYXRoRm9yRG9tYWluKGRvbWFpblBhdGgsIGBjZXJ0aWZpY2F0ZS5jcnRgKSkpIHtcbiAgICAgICAgZGVidWcoXG4gICAgICAgICAgICBgQ2FuJ3QgZmluZCBjZXJ0aWZpY2F0ZSBmaWxlIGZvciAke2RvbWFpbnN9LCBzbyBpdCBtdXN0IGJlIHRoZSBmaXJzdCByZXF1ZXN0IGZvciAke2RvbWFpbnN9LiBHZW5lcmF0aW5nIGFuZCBjYWNoaW5nIC4uLmBcbiAgICAgICAgKTtcbiAgICAgICAgYXdhaXQgZ2VuZXJhdGVEb21haW5DZXJ0aWZpY2F0ZShkb21haW5zKTtcbiAgICB9XG5cbiAgICBpZiAoIW9wdGlvbnMuc2tpcEhvc3RzRmlsZSkge1xuICAgICAgICBkb21haW5zLmZvckVhY2goYXN5bmMgKGRvbWFpbikgPT4ge1xuICAgICAgICAgICAgYXdhaXQgY3VycmVudFBsYXRmb3JtLmFkZERvbWFpblRvSG9zdEZpbGVJZk1pc3NpbmcoZG9tYWluKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZGVidWcoYFJldHVybmluZyBkb21haW4gY2VydGlmaWNhdGVgKTtcblxuICAgIGNvbnN0IHJldCA9IHtcbiAgICAgICAga2V5OiByZWFkRmlsZShkb21haW5LZXlQYXRoKSxcbiAgICAgICAgY2VydDogcmVhZEZpbGUoZG9tYWluQ2VydFBhdGgpLFxuICAgIH0gYXMgSVJldHVybkRhdGE8Tz47XG4gICAgaWYgKG9wdGlvbnMuZ2V0Q2FCdWZmZXIpIChyZXQgYXMgdW5rbm93biBhcyBJQ2FCdWZmZXIpLmNhID0gcmVhZEZpbGUocm9vdENBQ2VydFBhdGgpO1xuICAgIGlmIChvcHRpb25zLmdldENhUGF0aCkgKHJldCBhcyB1bmtub3duIGFzIElDYVBhdGgpLmNhUGF0aCA9IHJvb3RDQUNlcnRQYXRoO1xuXG4gICAgcmV0dXJuIHJldDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGhhc0NlcnRpZmljYXRlRm9yKHJlcXVlc3RlZERvbWFpbnM6IHN0cmluZyB8IHN0cmluZ1tdKSB7XG4gICAgY29uc3QgZG9tYWlucyA9IEFycmF5LmlzQXJyYXkocmVxdWVzdGVkRG9tYWlucykgPyByZXF1ZXN0ZWREb21haW5zIDogW3JlcXVlc3RlZERvbWFpbnNdO1xuICAgIGNvbnN0IGRvbWFpblBhdGggPSBnZXRTdGFibGVEb21haW5QYXRoKGRvbWFpbnMpO1xuICAgIHJldHVybiBleGlzdHMocGF0aEZvckRvbWFpbihkb21haW5QYXRoLCBgY2VydGlmaWNhdGUuY3J0YCkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY29uZmlndXJlZERvbWFpbnMoKSB7XG4gICAgcmV0dXJuIHJlYWRkaXIoZG9tYWluc0Rpcik7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiByZW1vdmVEb21haW4ocmVxdWVzdGVkRG9tYWluczogc3RyaW5nIHwgc3RyaW5nW10pIHtcbiAgICBjb25zdCBkb21haW5zID0gQXJyYXkuaXNBcnJheShyZXF1ZXN0ZWREb21haW5zKSA/IHJlcXVlc3RlZERvbWFpbnMgOiBbcmVxdWVzdGVkRG9tYWluc107XG4gICAgYXdhaXQgcmV2b2tlRG9tYWluQ2VydGlmaWNhdGUoZG9tYWlucyk7XG5cbiAgICBjb25zdCBkb21haW5QYXRoID0gZ2V0U3RhYmxlRG9tYWluUGF0aChkb21haW5zKTtcbiAgICByZXR1cm4gcmltcmFmLnN5bmMocGF0aEZvckRvbWFpbihkb21haW5QYXRoKSk7XG59XG4iXX0=