"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateKey = exports.revokeDomainCertificate = exports.generateDomainCertificate = void 0;
const tslib_1 = require("tslib");
// import path from 'path';
const debug_1 = tslib_1.__importDefault(require("debug"));
const fs_1 = require("fs");
const mkdirp_1 = require("mkdirp");
const certificate_authority_1 = require("./certificate-authority");
const constants_1 = require("./constants");
const utils_1 = require("./utils");
const debug = debug_1.default("devcert:certificates");
/**
 * Generate a domain certificate signed by the devcert root CA. Domain
 * certificates are cached in their own directories under
 * CONFIG_ROOT/domains/<domain>, and reused on subsequent requests. Because the
 * individual domain certificates are signed by the devcert root CA (which was
 * added to the OS/browser trust stores), they are trusted.
 */
function generateDomainCertificate(domains) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const domainPath = constants_1.getStableDomainPath(domains);
        mkdirp_1.sync(constants_1.pathForDomain(domainPath));
        debug(`Generating private key for ${domains}`);
        let domainKeyPath = constants_1.pathForDomain(domainPath, "private-key.key");
        generateKey(domainKeyPath);
        debug(`Generating certificate signing request for ${domains}`);
        let csrFile = constants_1.pathForDomain(domainPath, `certificate-signing-request.csr`);
        constants_1.withDomainSigningRequestConfig(domains, (configpath) => {
            utils_1.openssl(["req", "-new", "-config", configpath, "-key", domainKeyPath, "-out", csrFile]);
        });
        debug(`Generating certificate for ${domains} from signing request and signing with root CA`);
        let domainCertPath = constants_1.pathForDomain(domainPath, `certificate.crt`);
        yield certificate_authority_1.withCertificateAuthorityCredentials(({ caKeyPath, caCertPath }) => {
            constants_1.withDomainCertificateConfig(domains, (domainCertConfigPath) => {
                utils_1.openssl([
                    "ca",
                    "-config",
                    domainCertConfigPath,
                    "-in",
                    csrFile,
                    "-out",
                    domainCertPath,
                    "-keyfile",
                    caKeyPath,
                    "-cert",
                    caCertPath,
                    "-days",
                    "825",
                    "-batch",
                ]);
            });
        });
    });
}
exports.generateDomainCertificate = generateDomainCertificate;
/**
 * Revoke a domain certificate signed by the devcert root CA.
 */
function revokeDomainCertificate(domains) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const domainPath = constants_1.getStableDomainPath(domains);
        let domainCertPath = constants_1.pathForDomain(domainPath, `certificate.crt`);
        yield certificate_authority_1.withCertificateAuthorityCredentials(({ caKeyPath, caCertPath }) => {
            constants_1.withDomainCertificateConfig(domains, (domainCertConfigPath) => {
                utils_1.openssl([
                    "ca",
                    "-config",
                    domainCertConfigPath,
                    "-revoke",
                    domainCertPath,
                    "-keyfile",
                    caKeyPath,
                    "-cert",
                    caCertPath,
                ]);
            });
        });
    });
}
exports.revokeDomainCertificate = revokeDomainCertificate;
// Generate a cryptographic key, used to sign certificates or certificate signing requests.
function generateKey(filename) {
    debug(`generateKey: ${filename}`);
    utils_1.openssl(["genrsa", "-out", filename, "2048"]);
    fs_1.chmodSync(filename, 400);
}
exports.generateKey = generateKey;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2VydGlmaWNhdGVzLmpzIiwic291cmNlUm9vdCI6Ii4vIiwic291cmNlcyI6WyJjZXJ0aWZpY2F0ZXMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7OztBQUFBLDJCQUEyQjtBQUMzQiwwREFBZ0M7QUFDaEMsMkJBQXdDO0FBQ3hDLG1DQUF3QztBQUN4QyxtRUFBOEU7QUFDOUUsMkNBS3FCO0FBQ3JCLG1DQUFrQztBQUVsQyxNQUFNLEtBQUssR0FBRyxlQUFXLENBQUMsc0JBQXNCLENBQUMsQ0FBQztBQUVsRDs7Ozs7O0dBTUc7QUFDSCxTQUFzQix5QkFBeUIsQ0FBQyxPQUFpQjs7UUFDN0QsTUFBTSxVQUFVLEdBQUcsK0JBQW1CLENBQUMsT0FBTyxDQUFDLENBQUM7UUFDaEQsYUFBTSxDQUFDLHlCQUFhLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQztRQUVsQyxLQUFLLENBQUMsOEJBQThCLE9BQU8sRUFBRSxDQUFDLENBQUM7UUFDL0MsSUFBSSxhQUFhLEdBQUcseUJBQWEsQ0FBQyxVQUFVLEVBQUUsaUJBQWlCLENBQUMsQ0FBQztRQUNqRSxXQUFXLENBQUMsYUFBYSxDQUFDLENBQUM7UUFFM0IsS0FBSyxDQUFDLDhDQUE4QyxPQUFPLEVBQUUsQ0FBQyxDQUFDO1FBQy9ELElBQUksT0FBTyxHQUFHLHlCQUFhLENBQUMsVUFBVSxFQUFFLGlDQUFpQyxDQUFDLENBQUM7UUFDM0UsMENBQThCLENBQUMsT0FBTyxFQUFFLENBQUMsVUFBVSxFQUFFLEVBQUU7WUFDbkQsZUFBTyxDQUFDLENBQUMsS0FBSyxFQUFFLE1BQU0sRUFBRSxTQUFTLEVBQUUsVUFBVSxFQUFFLE1BQU0sRUFBRSxhQUFhLEVBQUUsTUFBTSxFQUFFLE9BQU8sQ0FBQyxDQUFDLENBQUM7UUFDNUYsQ0FBQyxDQUFDLENBQUM7UUFFSCxLQUFLLENBQUMsOEJBQThCLE9BQU8sZ0RBQWdELENBQUMsQ0FBQztRQUM3RixJQUFJLGNBQWMsR0FBRyx5QkFBYSxDQUFDLFVBQVUsRUFBRSxpQkFBaUIsQ0FBQyxDQUFDO1FBRWxFLE1BQU0sMkRBQW1DLENBQUMsQ0FBQyxFQUFFLFNBQVMsRUFBRSxVQUFVLEVBQUUsRUFBRSxFQUFFO1lBQ3BFLHVDQUEyQixDQUFDLE9BQU8sRUFBRSxDQUFDLG9CQUFvQixFQUFFLEVBQUU7Z0JBQzFELGVBQU8sQ0FBQztvQkFDSixJQUFJO29CQUNKLFNBQVM7b0JBQ1Qsb0JBQW9CO29CQUNwQixLQUFLO29CQUNMLE9BQU87b0JBQ1AsTUFBTTtvQkFDTixjQUFjO29CQUNkLFVBQVU7b0JBQ1YsU0FBUztvQkFDVCxPQUFPO29CQUNQLFVBQVU7b0JBQ1YsT0FBTztvQkFDUCxLQUFLO29CQUNMLFFBQVE7aUJBQ1gsQ0FBQyxDQUFDO1lBQ1AsQ0FBQyxDQUFDLENBQUM7UUFDUCxDQUFDLENBQUMsQ0FBQztJQUNQLENBQUM7Q0FBQTtBQXJDRCw4REFxQ0M7QUFFRDs7R0FFRztBQUNILFNBQXNCLHVCQUF1QixDQUFDLE9BQWlCOztRQUMzRCxNQUFNLFVBQVUsR0FBRywrQkFBbUIsQ0FBQyxPQUFPLENBQUMsQ0FBQztRQUNoRCxJQUFJLGNBQWMsR0FBRyx5QkFBYSxDQUFDLFVBQVUsRUFBRSxpQkFBaUIsQ0FBQyxDQUFDO1FBRWxFLE1BQU0sMkRBQW1DLENBQUMsQ0FBQyxFQUFFLFNBQVMsRUFBRSxVQUFVLEVBQUUsRUFBRSxFQUFFO1lBQ3BFLHVDQUEyQixDQUFDLE9BQU8sRUFBRSxDQUFDLG9CQUFvQixFQUFFLEVBQUU7Z0JBQzFELGVBQU8sQ0FBQztvQkFDSixJQUFJO29CQUNKLFNBQVM7b0JBQ1Qsb0JBQW9CO29CQUNwQixTQUFTO29CQUNULGNBQWM7b0JBQ2QsVUFBVTtvQkFDVixTQUFTO29CQUNULE9BQU87b0JBQ1AsVUFBVTtpQkFDYixDQUFDLENBQUM7WUFDUCxDQUFDLENBQUMsQ0FBQztRQUNQLENBQUMsQ0FBQyxDQUFDO0lBQ1AsQ0FBQztDQUFBO0FBbkJELDBEQW1CQztBQUVELDJGQUEyRjtBQUMzRixTQUFnQixXQUFXLENBQUMsUUFBZ0I7SUFDeEMsS0FBSyxDQUFDLGdCQUFnQixRQUFRLEVBQUUsQ0FBQyxDQUFDO0lBQ2xDLGVBQU8sQ0FBQyxDQUFDLFFBQVEsRUFBRSxNQUFNLEVBQUUsUUFBUSxFQUFFLE1BQU0sQ0FBQyxDQUFDLENBQUM7SUFDOUMsY0FBSyxDQUFDLFFBQVEsRUFBRSxHQUFHLENBQUMsQ0FBQztBQUN6QixDQUFDO0FBSkQsa0NBSUMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBpbXBvcnQgcGF0aCBmcm9tICdwYXRoJztcbmltcG9ydCBjcmVhdGVEZWJ1ZyBmcm9tIFwiZGVidWdcIjtcbmltcG9ydCB7IGNobW9kU3luYyBhcyBjaG1vZCB9IGZyb20gXCJmc1wiO1xuaW1wb3J0IHsgc3luYyBhcyBta2RpcnAgfSBmcm9tIFwibWtkaXJwXCI7XG5pbXBvcnQgeyB3aXRoQ2VydGlmaWNhdGVBdXRob3JpdHlDcmVkZW50aWFscyB9IGZyb20gXCIuL2NlcnRpZmljYXRlLWF1dGhvcml0eVwiO1xuaW1wb3J0IHtcbiAgICBnZXRTdGFibGVEb21haW5QYXRoLFxuICAgIHBhdGhGb3JEb21haW4sXG4gICAgd2l0aERvbWFpbkNlcnRpZmljYXRlQ29uZmlnLFxuICAgIHdpdGhEb21haW5TaWduaW5nUmVxdWVzdENvbmZpZyxcbn0gZnJvbSBcIi4vY29uc3RhbnRzXCI7XG5pbXBvcnQgeyBvcGVuc3NsIH0gZnJvbSBcIi4vdXRpbHNcIjtcblxuY29uc3QgZGVidWcgPSBjcmVhdGVEZWJ1ZyhcImRldmNlcnQ6Y2VydGlmaWNhdGVzXCIpO1xuXG4vKipcbiAqIEdlbmVyYXRlIGEgZG9tYWluIGNlcnRpZmljYXRlIHNpZ25lZCBieSB0aGUgZGV2Y2VydCByb290IENBLiBEb21haW5cbiAqIGNlcnRpZmljYXRlcyBhcmUgY2FjaGVkIGluIHRoZWlyIG93biBkaXJlY3RvcmllcyB1bmRlclxuICogQ09ORklHX1JPT1QvZG9tYWlucy88ZG9tYWluPiwgYW5kIHJldXNlZCBvbiBzdWJzZXF1ZW50IHJlcXVlc3RzLiBCZWNhdXNlIHRoZVxuICogaW5kaXZpZHVhbCBkb21haW4gY2VydGlmaWNhdGVzIGFyZSBzaWduZWQgYnkgdGhlIGRldmNlcnQgcm9vdCBDQSAod2hpY2ggd2FzXG4gKiBhZGRlZCB0byB0aGUgT1MvYnJvd3NlciB0cnVzdCBzdG9yZXMpLCB0aGV5IGFyZSB0cnVzdGVkLlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2VuZXJhdGVEb21haW5DZXJ0aWZpY2F0ZShkb21haW5zOiBzdHJpbmdbXSk6IFByb21pc2U8dm9pZD4ge1xuICAgIGNvbnN0IGRvbWFpblBhdGggPSBnZXRTdGFibGVEb21haW5QYXRoKGRvbWFpbnMpO1xuICAgIG1rZGlycChwYXRoRm9yRG9tYWluKGRvbWFpblBhdGgpKTtcblxuICAgIGRlYnVnKGBHZW5lcmF0aW5nIHByaXZhdGUga2V5IGZvciAke2RvbWFpbnN9YCk7XG4gICAgbGV0IGRvbWFpbktleVBhdGggPSBwYXRoRm9yRG9tYWluKGRvbWFpblBhdGgsIFwicHJpdmF0ZS1rZXkua2V5XCIpO1xuICAgIGdlbmVyYXRlS2V5KGRvbWFpbktleVBhdGgpO1xuXG4gICAgZGVidWcoYEdlbmVyYXRpbmcgY2VydGlmaWNhdGUgc2lnbmluZyByZXF1ZXN0IGZvciAke2RvbWFpbnN9YCk7XG4gICAgbGV0IGNzckZpbGUgPSBwYXRoRm9yRG9tYWluKGRvbWFpblBhdGgsIGBjZXJ0aWZpY2F0ZS1zaWduaW5nLXJlcXVlc3QuY3NyYCk7XG4gICAgd2l0aERvbWFpblNpZ25pbmdSZXF1ZXN0Q29uZmlnKGRvbWFpbnMsIChjb25maWdwYXRoKSA9PiB7XG4gICAgICAgIG9wZW5zc2woW1wicmVxXCIsIFwiLW5ld1wiLCBcIi1jb25maWdcIiwgY29uZmlncGF0aCwgXCIta2V5XCIsIGRvbWFpbktleVBhdGgsIFwiLW91dFwiLCBjc3JGaWxlXSk7XG4gICAgfSk7XG5cbiAgICBkZWJ1ZyhgR2VuZXJhdGluZyBjZXJ0aWZpY2F0ZSBmb3IgJHtkb21haW5zfSBmcm9tIHNpZ25pbmcgcmVxdWVzdCBhbmQgc2lnbmluZyB3aXRoIHJvb3QgQ0FgKTtcbiAgICBsZXQgZG9tYWluQ2VydFBhdGggPSBwYXRoRm9yRG9tYWluKGRvbWFpblBhdGgsIGBjZXJ0aWZpY2F0ZS5jcnRgKTtcblxuICAgIGF3YWl0IHdpdGhDZXJ0aWZpY2F0ZUF1dGhvcml0eUNyZWRlbnRpYWxzKCh7IGNhS2V5UGF0aCwgY2FDZXJ0UGF0aCB9KSA9PiB7XG4gICAgICAgIHdpdGhEb21haW5DZXJ0aWZpY2F0ZUNvbmZpZyhkb21haW5zLCAoZG9tYWluQ2VydENvbmZpZ1BhdGgpID0+IHtcbiAgICAgICAgICAgIG9wZW5zc2woW1xuICAgICAgICAgICAgICAgIFwiY2FcIixcbiAgICAgICAgICAgICAgICBcIi1jb25maWdcIixcbiAgICAgICAgICAgICAgICBkb21haW5DZXJ0Q29uZmlnUGF0aCxcbiAgICAgICAgICAgICAgICBcIi1pblwiLFxuICAgICAgICAgICAgICAgIGNzckZpbGUsXG4gICAgICAgICAgICAgICAgXCItb3V0XCIsXG4gICAgICAgICAgICAgICAgZG9tYWluQ2VydFBhdGgsXG4gICAgICAgICAgICAgICAgXCIta2V5ZmlsZVwiLFxuICAgICAgICAgICAgICAgIGNhS2V5UGF0aCxcbiAgICAgICAgICAgICAgICBcIi1jZXJ0XCIsXG4gICAgICAgICAgICAgICAgY2FDZXJ0UGF0aCxcbiAgICAgICAgICAgICAgICBcIi1kYXlzXCIsXG4gICAgICAgICAgICAgICAgXCI4MjVcIixcbiAgICAgICAgICAgICAgICBcIi1iYXRjaFwiLFxuICAgICAgICAgICAgXSk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xufVxuXG4vKipcbiAqIFJldm9rZSBhIGRvbWFpbiBjZXJ0aWZpY2F0ZSBzaWduZWQgYnkgdGhlIGRldmNlcnQgcm9vdCBDQS5cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHJldm9rZURvbWFpbkNlcnRpZmljYXRlKGRvbWFpbnM6IHN0cmluZ1tdKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgY29uc3QgZG9tYWluUGF0aCA9IGdldFN0YWJsZURvbWFpblBhdGgoZG9tYWlucyk7XG4gICAgbGV0IGRvbWFpbkNlcnRQYXRoID0gcGF0aEZvckRvbWFpbihkb21haW5QYXRoLCBgY2VydGlmaWNhdGUuY3J0YCk7XG5cbiAgICBhd2FpdCB3aXRoQ2VydGlmaWNhdGVBdXRob3JpdHlDcmVkZW50aWFscygoeyBjYUtleVBhdGgsIGNhQ2VydFBhdGggfSkgPT4ge1xuICAgICAgICB3aXRoRG9tYWluQ2VydGlmaWNhdGVDb25maWcoZG9tYWlucywgKGRvbWFpbkNlcnRDb25maWdQYXRoKSA9PiB7XG4gICAgICAgICAgICBvcGVuc3NsKFtcbiAgICAgICAgICAgICAgICBcImNhXCIsXG4gICAgICAgICAgICAgICAgXCItY29uZmlnXCIsXG4gICAgICAgICAgICAgICAgZG9tYWluQ2VydENvbmZpZ1BhdGgsXG4gICAgICAgICAgICAgICAgXCItcmV2b2tlXCIsXG4gICAgICAgICAgICAgICAgZG9tYWluQ2VydFBhdGgsXG4gICAgICAgICAgICAgICAgXCIta2V5ZmlsZVwiLFxuICAgICAgICAgICAgICAgIGNhS2V5UGF0aCxcbiAgICAgICAgICAgICAgICBcIi1jZXJ0XCIsXG4gICAgICAgICAgICAgICAgY2FDZXJ0UGF0aCxcbiAgICAgICAgICAgIF0pO1xuICAgICAgICB9KTtcbiAgICB9KTtcbn1cblxuLy8gR2VuZXJhdGUgYSBjcnlwdG9ncmFwaGljIGtleSwgdXNlZCB0byBzaWduIGNlcnRpZmljYXRlcyBvciBjZXJ0aWZpY2F0ZSBzaWduaW5nIHJlcXVlc3RzLlxuZXhwb3J0IGZ1bmN0aW9uIGdlbmVyYXRlS2V5KGZpbGVuYW1lOiBzdHJpbmcpOiB2b2lkIHtcbiAgICBkZWJ1ZyhgZ2VuZXJhdGVLZXk6ICR7ZmlsZW5hbWV9YCk7XG4gICAgb3BlbnNzbChbXCJnZW5yc2FcIiwgXCItb3V0XCIsIGZpbGVuYW1lLCBcIjIwNDhcIl0pO1xuICAgIGNobW9kKGZpbGVuYW1lLCA0MDApO1xufVxuIl19